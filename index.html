<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System 6 Animator</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- GIF Encoder Library (ES Module Version) -->
    <script type="module">
        import { GIFEncoder } from 'https://cdn.jsdelivr.net/npm/gifenc@1.0.3/dist/gifenc.esm.js';
        // Attach to window so the rest of the app can see it
        window.gifenc = { GIFEncoder };
    </script>

    <style>
        /* --- System 6 Theme Styles --- */
        :root {
            --bg-pattern: repeating-linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc),
                          repeating-linear-gradient(45deg, #ccc 25%, #f0f0f0 25%, #f0f0f0 75%, #ccc 75%, #ccc);
            --sys-black: #000;
            --sys-white: #fff;
            --sys-grey: #aaa; /* Onion skin color */
            --shadow: 2px 2px 0px var(--sys-black);
        }

        body {
            font-family: 'VT323', monospace;
            background-color: #f0f0f0;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Changed from center to allow scrolling */
            min-height: 100vh;
            color: var(--sys-black);
            user-select: none;
            -webkit-user-select: none;
            /* Reverted overflow/height locks to allow scrolling */
        }

        /* The Main Window */
        .window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px; /* Space at bottom for scrolling */
        }

        /* Title Bar */
        .title-bar {
            background: var(--sys-black);
            color: var(--sys-white);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--sys-black);
            font-size: 1.2rem;
            letter-spacing: 1px;
        }
        
        .title-lines {
            flex-grow: 1;
            height: 12px;
            margin: 0 10px;
            background: repeating-linear-gradient(
                to bottom,
                var(--sys-white),
                var(--sys-white) 1px,
                var(--sys-black) 1px,
                var(--sys-black) 2px
            );
        }

        .close-box {
            width: 12px;
            height: 12px;
            background: var(--sys-white);
            border: 1px solid var(--sys-white);
            box-shadow: inset 1px 1px 0 #000;
        }

        /* Main Content Area */
        .content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
            padding-bottom: 10px;
            border-bottom: 1px dashed var(--sys-black);
        }

        .btn {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            padding: 5px 10px;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--sys-black);
            transition: transform 0.1s;
            text-transform: uppercase;
            text-decoration: none;
            color: var(--sys-black);
            display: inline-block;
            text-align: center;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: none;
            background: var(--sys-black);
            color: var(--sys-white);
        }

        .btn.active {
            background: var(--sys-black);
            color: var(--sys-white);
            box-shadow: inset 2px 2px 0px rgba(255,255,255,0.2);
        }

        .btn:disabled {
            color: #aaa;
            border-color: #aaa;
            box-shadow: none;
            cursor: default;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
            border: 1px solid var(--sys-black);
            padding: 3px;
            flex-wrap: wrap; /* Allow buttons to wrap on very small screens */
            justify-content: center;
        }

        .control-group-title {
            font-size: 0.8rem;
            margin-right: 5px;
            font-weight: bold;
        }

        /* Canvas Area */
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e0e0e0;
            padding: 10px;
            border: 1px inset var(--sys-black);
            position: relative;
        }

        canvas {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            cursor: crosshair;
            image-rendering: pixelated;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            
            /* Responsive resizing */
            width: 100%;
            height: auto;
            max-width: 320px; /* Limit max size */
            aspect-ratio: 1 / 1; 

            /* CRITICAL: Prevents scrolling ONLY when touching the canvas */
            touch-action: none; 
        }

        /* Film Strip (Timeline) */
        .film-strip {
            display: flex;
            gap: 5px;
            overflow-x: auto;
            padding: 5px 0;
            height: 60px;
            border-top: 2px solid var(--sys-black);
            background: #ddd;
            scrollbar-width: thin;
        }
        
        .film-frame {
            min-width: 50px;
            width: 50px;
            height: 50px;
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            position: relative;
            cursor: pointer;
            image-rendering: pixelated;
            flex-shrink: 0;
        }

        .film-frame.selected {
            border: 3px solid red; /* Highlight current frame strongly */
            box-shadow: 0 0 5px red;
        }

        .film-frame canvas {
            width: 100%;
            height: 100%;
            border: none;
            box-shadow: none;
            pointer-events: none;
            touch-action: auto; /* Timeline doesn't need to block scroll */
        }

        .frame-number {
            position: absolute;
            bottom: 0;
            right: 0;
            background: var(--sys-black);
            color: var(--sys-white);
            font-size: 10px;
            padding: 1px 3px;
        }

        /* Playback Controls */
        .playback-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 5px;
        }
        
        label {
            font-size: 1.1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            width: 100px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--sys-black);
            cursor: pointer;
            margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: var(--sys-black);
        }

        /* Responsive */
        @media (max-width: 500px) {
            body { padding: 5px; }
            .window { border-width: 2px; }
            .btn { font-size: 0.9rem; padding: 4px 6px; }
            .film-strip { height: 45px; }
            .film-frame { min-width: 35px; width: 35px; height: 35px; }
            .control-group { flex-wrap: wrap; justify-content: center;}
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div class="window">
    <div class="title-bar">
        <div class="close-box"></div>
        <div class="title-lines"></div>
        <span>PIXEL.ANIM</span>
        <div class="title-lines"></div>
    </div>

    <div class="content">
        <!-- Tools Row 1 -->
        <div class="toolbar">
            <div class="control-group">
                <button class="btn active" id="tool-pen" onclick="setTool('pen')">Pen</button>
                <button class="btn" id="tool-eraser" onclick="setTool('eraser')">Eraser</button>
                <button class="btn" onclick="clearFrame()">Clear</button>
            </div>
            
            <div class="control-group">
                <select id="grid-size" class="btn" onchange="changeGridSize()">
                    <option value="8">8x8</option>
                    <option value="16">16x16</option>
                    <option value="32">32x32</option>
                </select>
                <button class="btn" onclick="startOver()" style="color:red; font-weight:bold;">Reset</button>
            </div>
        </div>

        <!-- Tools Row 2 (Files) -->
        <div class="toolbar" style="border-top:none; padding-top:0;">
            <div class="control-group" style="flex-grow: 1; justify-content: center;">
                <span class="control-group-title">FILE:</span>
                <button class="btn" onclick="saveProject()">Save</button>
                <button class="btn" onclick="document.getElementById('file-input').click()">Load</button>
                <button class="btn" onclick="exportGIF()" title="Download GIF">EXPORT GIF</button>
            </div>
        </div>
        
        <!-- Hidden File Input -->
        <input type="file" id="file-input" style="display:none" accept=".json" onchange="loadProject(event)">

        <!-- Main Canvas -->
        <div class="canvas-container">
            <canvas id="editorCanvas" width="320" height="320"></canvas>
        </div>

        <!-- Animation Controls -->
        <div class="toolbar" style="border-bottom: none; border-top: 1px dashed var(--sys-black); padding-top: 10px;">
            <button class="btn" id="save-cel-btn" onclick="saveCelAndNext()" style="flex-grow: 2; font-weight: bold;">+ Save Cel</button>
            <button class="btn" onclick="duplicateFrame()" title="Duplicate Current Frame" style="flex-grow: 1;">Dup</button>
            <button class="btn" onclick="deleteFrame()" style="color:red; font-weight:bold;">X</button>
        </div>

        <!-- Playback -->
        <div class="playback-controls">
            <button class="btn" id="play-btn" onclick="togglePlay()">&#9658; PLAY</button>
            <div style="display:flex; align-items:center; gap:5px;">
                <label>Speed:</label>
                <input type="range" id="speed-range" min="1" max="20" value="8" oninput="updateSpeed()">
            </div>
        </div>

        <!-- Timeline -->
        <div class="film-strip" id="film-strip">
            <!-- Thumbnails go here -->
        </div>
        <div style="text-align:center; font-size: 0.8rem; margin-top: 2px;">
            Frame: <span id="frame-indicator">1/1</span>
        </div>
    </div>
</div>

<script>
    // --- Configuration ---
    let gridSize = 8;
    // Note: Internal resolution stays 320 for quality, but CSS scales it
    const canvasSize = 320; 
    let pixelSize = canvasSize / gridSize;
    
    // --- State ---
    let frames = []; // Array of 2D arrays (0=empty, 1=black)
    let currentFrameIndex = 0;
    let isPlaying = false;
    let playInterval = null;
    let fps = 8;
    let tool = 'pen'; // 'pen' or 'eraser'
    let isDrawing = false;
    let showOnionSkin = true;

    // --- DOM Elements ---
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const filmStrip = document.getElementById('film-strip');
    const frameIndicator = document.getElementById('frame-indicator');
    const playBtn = document.getElementById('play-btn');

    // --- Initialization ---
    function init() {
        // Initialize with one empty frame
        addNewFrame();
        render();
        updateUI();
    }

    // --- Grid Logic ---

    function createEmptyGrid(size) {
        let grid = [];
        for (let y = 0; y < size; y++) {
            let row = [];
            for (let x = 0; x < size; x++) {
                row.push(0);
            }
            grid.push(row);
        }
        return grid;
    }

    function startOver() {
        if (frames.length > 1 || hasContent(frames[0])) {
            if (!confirm("Start over? This will delete your entire animation.")) return;
        }
        forceReset();
    }

    function forceReset() {
        if (isPlaying) stopAnimation();
        frames = [];
        currentFrameIndex = 0;
        filmStrip.innerHTML = '';
        
        // Ensure grid settings match current dropdown
        const select = document.getElementById('grid-size');
        gridSize = parseInt(select.value);
        pixelSize = canvasSize / gridSize;

        addNewFrame();
        render();
        updateUI();
    }

    function changeGridSize() {
        const select = document.getElementById('grid-size');
        const newSize = parseInt(select.value);
        
        if (frames.length > 1 || hasContent(frames[0])) {
            if(!confirm("Changing grid size will reset your animation. Continue?")) {
                select.value = gridSize;
                return;
            }
        }
        
        gridSize = newSize;
        pixelSize = canvasSize / gridSize;
        forceReset();
    }

    function hasContent(grid) {
        return grid.some(row => row.some(cell => cell === 1));
    }

    // --- File System (Save/Load/Export) ---

    function getTimestampFilename(extension) {
        const now = new Date();
        const day = String(now.getDate()).padStart(2, '0');
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const hour = String(now.getHours()).padStart(2, '0');
        const minute = String(now.getMinutes()).padStart(2, '0');
        return `pixart${day}${month}${hour}${minute}.${extension}`;
    }

    function saveProject() {
        const projectData = {
            gridSize: gridSize,
            fps: fps,
            frames: frames
        };
        const blob = new Blob([JSON.stringify(projectData)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = getTimestampFilename('json');
        a.click();
        URL.revokeObjectURL(url);
    }

    function loadProject(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                
                // Validate Basic Structure
                if (!data.frames || !Array.isArray(data.frames)) {
                    alert("Invalid project file.");
                    return;
                }

                if (isPlaying) stopAnimation();

                // Apply settings
                if (data.gridSize) {
                    gridSize = data.gridSize;
                    document.getElementById('grid-size').value = gridSize;
                    pixelSize = canvasSize / gridSize;
                }
                if (data.fps) {
                    fps = data.fps;
                    document.getElementById('speed-range').value = fps;
                }

                // Load frames
                frames = data.frames;
                currentFrameIndex = 0;

                // Rebuild UI
                filmStrip.innerHTML = '';
                refreshThumbnails();
                render();
                updateUI();
                
                // Clear input so same file can be selected again
                event.target.value = '';

            } catch (err) {
                console.error(err);
                alert("Error loading file.");
            }
        };
        reader.readAsText(file);
    }

    function exportGIF() {
        // Robust Library Check
        if (!window.gifenc) {
            alert("The GIF library hasn't loaded yet. Please check your internet connection or wait a few seconds.");
            return;
        }

        const btn = document.querySelector('button[onclick="exportGIF()"]');
        const originalText = btn.innerText;
        btn.innerText = "Generating...";
        btn.disabled = true;

        setTimeout(() => {
            try {
                // Get GIFEncoder from the global object we created
                const { GIFEncoder } = window.gifenc;
                const gif = new GIFEncoder();
                
                // We want the output to be big enough to see, so we scale it.
                // 320x320 is the canvas size. Let's use that.
                // Calculate scale factor
                const scale = Math.floor(canvasSize / gridSize);
                const width = canvasSize;
                const height = canvasSize;

                // Palette: 0=White, 1=Black
                const palette = [
                    [255, 255, 255],
                    [0, 0, 0]
                ];

                frames.forEach(frame => {
                    // Create indexed color array for this frame
                    const data = new Uint8Array(width * height);
                    
                    for (let y = 0; y < gridSize; y++) {
                        for (let x = 0; x < gridSize; x++) {
                            const colorIndex = frame[y][x] === 1 ? 1 : 0;
                            
                            // Fill the scaled block
                            // The canvasSize is 320. If gridSize is 8, scale is 40.
                            const startY = y * scale;
                            const startX = x * scale;
                            
                            for (let dy = 0; dy < scale; dy++) {
                                for (let dx = 0; dx < scale; dx++) {
                                    const py = startY + dy;
                                    const px = startX + dx;
                                    if (py < height && px < width) {
                                        data[py * width + px] = colorIndex;
                                    }
                                }
                            }
                        }
                    }

                    gif.writeFrame(data, width, height, {
                    palette: palette,
                    delay: 1000 / fps, // FPS from slider
                    repeat: 0, // Loop forever
                    transparent: false
                });
            });

            gif.finish();
            const buffer = gif.bytes();
            
            // Trigger Download
            const blob = new Blob([buffer], { type: 'image/gif' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = getTimestampFilename('gif');
            a.click();
            URL.revokeObjectURL(url);
            
        } catch (e) {
            console.error(e);
            alert("Error generating GIF: " + e.message);
        } finally {
            btn.innerText = originalText;
            btn.disabled = false;
        }
    }, 50); // Small timeout to allow UI to update
}

// --- Frame Management ---

    function addNewFrame(copyPrevious = false) {
        let newGrid;
        if (copyPrevious && frames.length > 0) {
            // Deep copy the previous frame
            newGrid = JSON.parse(JSON.stringify(frames[frames.length - 1]));
        } else {
            newGrid = createEmptyGrid(gridSize);
        }
        frames.push(newGrid);
        currentFrameIndex = frames.length - 1;
        addThumbnail(currentFrameIndex);
        scrollToEnd();
    }

    function duplicateFrame() {
        if (frames.length === 0) return;

        const newGrid = JSON.parse(JSON.stringify(frames[currentFrameIndex]));
        frames.splice(currentFrameIndex + 1, 0, newGrid);
        currentFrameIndex++;
        
        refreshThumbnails();
        render();
        updateUI();
        
        setTimeout(() => {
            const thumb = filmStrip.children[currentFrameIndex];
            if (thumb) thumb.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }, 50);
    }

    function saveCelAndNext() {
        if (currentFrameIndex < frames.length - 1) {
            currentFrameIndex++;
        } else {
            addNewFrame(false);
        }
        render();
        updateUI();
    }

    function deleteFrame() {
        if (frames.length <= 1) {
            clearFrame();
            return;
        }
        
        if (confirm("Delete this frame?")) {
            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) {
                currentFrameIndex = frames.length - 1;
            }
            refreshThumbnails();
            render();
            updateUI();
        }
    }

    function clearFrame() {
        frames[currentFrameIndex] = createEmptyGrid(gridSize);
        render();
        updateThumbnail(currentFrameIndex);
    }

    function selectFrame(index) {
        if (isPlaying) stopAnimation();
        currentFrameIndex = index;
        render();
        updateUI();
    }

    // --- Drawing Engine ---

    function drawGridLines() {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= gridSize; i++) {
            ctx.moveTo(i * pixelSize, 0);
            ctx.lineTo(i * pixelSize, canvasSize);
            ctx.moveTo(0, i * pixelSize);
            ctx.lineTo(canvasSize, i * pixelSize);
        }
        ctx.stroke();
    }

    function drawPixel(x, y, color) {
        ctx.fillStyle = color;
        const gap = 0; 
        ctx.fillRect(x * pixelSize + gap, y * pixelSize + gap, pixelSize - gap*2, pixelSize - gap*2);
    }

    function render() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        drawGridLines();

        if (!isPlaying && showOnionSkin && currentFrameIndex > 0) {
            const prevFrame = frames[currentFrameIndex - 1];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (prevFrame[y][x] === 1) {
                        drawPixel(x, y, '#ccc');
                    }
                }
            }
        }

        const currentGrid = frames[currentFrameIndex];
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (currentGrid[y][x] === 1) {
                    drawPixel(x, y, '#000');
                }
            }
        }
        updateThumbnail(currentFrameIndex);
    }

    // --- Interaction ---

    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // Use rect.width and rect.height because they reflect the actual screen size (CSS scale)
        const x = Math.floor((clientX - rect.left) / (rect.width / gridSize));
        const y = Math.floor((clientY - rect.top) / (rect.height / gridSize));
        return { x, y };
    }

    function handlePaint(e) {
        if (isPlaying) return;
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            const val = tool === 'pen' ? 1 : 0;
            if (frames[currentFrameIndex][y][x] !== val) {
                frames[currentFrameIndex][y][x] = val;
                render();
            }
        }
        // Critical for touch devices: stop the browser from scrolling
        if (e.cancelable) e.preventDefault();
    }

    canvas.addEventListener('mousedown', (e) => { isDrawing = true; handlePaint(e); });
    canvas.addEventListener('mousemove', (e) => { if (isDrawing) handlePaint(e); });
    window.addEventListener('mouseup', () => { isDrawing = false; });
    canvas.addEventListener('touchstart', (e) => { isDrawing = true; handlePaint(e); }, {passive: false});
    canvas.addEventListener('touchmove', (e) => { if (isDrawing) handlePaint(e); }, {passive: false});
    canvas.addEventListener('touchend', () => { isDrawing = false; });

    // --- Toolbar ---

    function setTool(t) {
        tool = t;
        document.getElementById('tool-pen').classList.toggle('active', t === 'pen');
        document.getElementById('tool-eraser').classList.toggle('active', t === 'eraser');
    }

    // --- Timeline UI ---

    function addThumbnail(index) {
        const thumb = document.createElement('div');
        thumb.className = 'film-frame';
        thumb.onclick = () => selectFrame(index);
        
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = gridSize;
        thumbCanvas.height = gridSize;
        thumb.appendChild(thumbCanvas);
        
        const num = document.createElement('div');
        num.className = 'frame-number';
        num.innerText = index + 1;
        thumb.appendChild(num);

        filmStrip.appendChild(thumb);
    }

    function updateThumbnail(index) {
        if (index < 0 || index >= filmStrip.children.length) return;
        const thumb = filmStrip.children[index];
        const thumbCanvas = thumb.querySelector('canvas');
        const tCtx = thumbCanvas.getContext('2d');
        const grid = frames[index];
        tCtx.clearRect(0, 0, gridSize, gridSize);
        tCtx.fillStyle = '#000';
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) tCtx.fillRect(x, y, 1, 1);
            }
        }
    }

    function refreshThumbnails() {
        filmStrip.innerHTML = '';
        frames.forEach((_, idx) => addThumbnail(idx));
        frames.forEach((_, idx) => updateThumbnail(idx));
    }

    function updateUI() {
        frameIndicator.innerText = `${currentFrameIndex + 1}/${frames.length}`;
        Array.from(filmStrip.children).forEach((child, idx) => {
            if (idx === currentFrameIndex) child.classList.add('selected');
            else child.classList.remove('selected');
        });
        const saveBtn = document.getElementById('save-cel-btn');
        if (currentFrameIndex === frames.length - 1) {
            saveBtn.innerText = "+ Save Cel";
        } else {
            saveBtn.innerText = "Next Frame >";
        }
    }

    function scrollToEnd() {
        setTimeout(() => { filmStrip.scrollLeft = filmStrip.scrollWidth; }, 50);
    }

    // --- Playback ---

    function togglePlay() {
        if (isPlaying) stopAnimation();
        else startAnimation();
    }

    function startAnimation() {
        if (frames.length < 1) return;
        isPlaying = true;
        playBtn.innerHTML = '&#9632; STOP';
        document.getElementById('save-cel-btn').disabled = true;
        canvas.style.cursor = 'default';

        playInterval = setInterval(() => {
            currentFrameIndex = (currentFrameIndex + 1) % frames.length;
            render();
            updateUI(); 
        }, 1000 / fps);
    }

    function stopAnimation() {
        isPlaying = false;
        clearInterval(playInterval);
        playBtn.innerHTML = '&#9658; PLAY';
        document.getElementById('save-cel-btn').disabled = false;
        canvas.style.cursor = 'crosshair';
        render();
    }

    function updateSpeed() {
        const slider = document.getElementById('speed-range');
        fps = parseInt(slider.value);
        if (isPlaying) {
            stopAnimation();
            startAnimation();
        }
    }

    // --- Start ---
    init();

</script>

</body>
</html>
